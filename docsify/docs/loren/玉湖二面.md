## 1.什么时候重写equals？
1、==用来比较两个变量的值是否相等，一般用于比较基本数据类型，如果比较的变量为引用类型（对象）的时候，比如：Object a = new Object()，a占用一块内存，new Object()占用另一块内存，a中存储的值就是new Object()内存的首地址。    

2、equals方法比较的是两个独立对象的内容是否相等。String a = new String(“uzi”); String b = new String(“uzi”); 这时a==b为false，a.equals(b)为true。    

答：比较两个实例是否相等时重写equals()。
equals()用于比较两个实例是否相等，两实例属性对应相等    =>    两实例相等   
只单纯比较两个同类型实例是否相等时只重写equals()就可以。   

什么时候重写hashCode？
答：自定义类型作为HashMap的key

2.什么时候重写equlas，就要重写hashcode方法？   
类里要用到hashmap、hashSet等散列表(来达到去重效果)的时候。如果在我们的类中，不需要用到散列表，那么只需要重写equals即可。因为重写equals方法，仅仅是为了满足我们特定的需求（一般是比较属性值是否相同）。而不重写hashcode，并不会影响我们实现这类需求。    

3.为什么使用散列表时重写equals，还有重写hashcode？   
因为hashcode默认使用地址进行散列的。此时equals比较是相同的，但是hashmap内部却仍然认为这是两个对象，导致运行结果和我们期望的不符。    

                        
原文链接：https://blog.csdn.net/HFish24/article/details/107652227


## 2.在Java中，HashMap在put时如何比较链表中的key-value对，
实际上是在处理碰撞后的链表结构。当发生碰撞，即两个key的hash值在数组中的位置相同时，
HashMap会将这两个key-value对放入同一个数组位置，并以链表的形式链接。在进行get操作时，HashMap会先计算key的hash值找到数组中的位置，然后遍历链表，
使用equals方法比较链表中的每个节点的key，直到找到相等的节点或链表结束。

以下是一个简化的示例代码，展示了HashMap在put和get时如何比较链表中的key-value对：

import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();

        map.put("apple", "fruit");
        map.put("orange", "fruit"); // 碰撞，两个key的hash值相同

        // 输出get操作中比较链表节点的过程
        System.out.println(map.get("orange")); // 遍历链表，比较字符串内容直到找到"orange"
    }
}
在上述代码中，当我们尝试获取"orange"时，HashMap会先找到数组中的位置，然后遍历链表，对比链表中的每个节点的key（这里是String对象），
直到找到key为"orange"的节点，然后返回其value。这里的关键在于String类重写了equals方法，能够正确地比较字符串内容。
如果自定义了一个对象作为HashMap的key，那么需要确保重写了equals和hashCode方法，以便正确地进行比较和哈希计算


## 3.设计RPC框架
##### RPC的技术要点
在RPC的实现中，有多种技术可以选择，如：

RPC框架：实现RPC的一种基础设施，包括协议解析，网络通信，序列化和反序列化，负载均衡等功能。

序列化和反序列化：将数据结构或对象转换为可以在网络上传输的格式和从网络接收的格式。

协议：定义消息格式和通信规则。常见的RPC协议包括HTTP，TCP，UDP等。

负载均衡：在多个服务提供者之间进行负载均衡，减少单个服务提供者的负荷。

##### RPC的实现案例
除了上面提到的技术，还有一些其他的RPC相关技术，如：

RESTful API：RESTful是一种设计风格，也可以用于分布式系统中的通信。它包括一组协议和约束条件，可用于提高系统的可伸缩性，可移植性和可靠性。

gRPC：由Google开发的，基于HTTP/2协议的RPC框架，支持多种编程语言和平台。

Thrift：由Facebook开发的，支持多种编程语言和平台的RPC框架，包括Java，Python，C#和Ruby等。

Dubbo：由阿里巴巴开发的，基于Java语言的RPC框架，支持服务治理和容错机制。

##### 实现RPC
 [实现方案](https://www.kancloud.cn/littlelittlebear/guide-rpc-framework/2097789) 


## 4.链路追踪
#### 目前市场上比较常见的链路追踪方案如下

Zipkin是Twitter开源的调用链分析工具，目前基于springcloud sleuth得到了广泛的使用，特点是轻量，使用部署简单。   
Pinpoint是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能强大，接入端无代码侵入。  
SkyWalking 是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能较强，接入端无代码侵入。目前已加入Apache孵化器。   
CAT（Central Application Tracking）是大众点评开源的基于编码和配置的调用链分析，应用监控分析，日志采集，监控报警等一系列的监控平台工具。    
jaeger 受到Dapper和OpenZipkin的启发，是由Uber Technologies创建 并捐赠给Cloud Native Computing Foundation的分布式追踪平台。  

#####  skywalking的工作机制
skywalking的工作机制，需要三块协同。工作原理图大致如下:  
skywalking server：负责接收、存储并展示，所以server模块包含一个展示web子模块；  
agent：负责代理微服务并收集需要的信息，转发给server；  
微服务本身：需要在启动时指定agent，以便生成代理类。  

##### 主要组件
SkyWalking采用组件式开发，易于扩展，主要组件作用如下：   
Skywalking Agent：链路数据采集tracing（调用链数据）和metric（指标）信息并上报，上报通过HTTP或者gRPC方式发送数据到Skywalking Collector   
Skywalking Collector ： 链路数据收集器，对agent传过来的tracing和metric数据进行整合分析通过Analysis Core模块处理并落入相关的数据存储中，    
同时会通过Query Core模块进行二次统计和监控告警   
Storage： Skywalking的存储，支持以ElasticSearch、Mysql、TiDB、H2等主流存储作为存储介质进行数据存储,H2仅作为临时演示单机用。   
SkyWalking UI： Web可视化平台，用来展示落地的数据，目前官方采纳了RocketBot作为SkyWalking的主UI  

##### 定位问题   
在使用SkyWalking进行链路追踪定位问题时，通常会涉及以下步骤：  
分析告警信息：首先需要查看SkyWalking提供的告警信息，了解是哪种类型的问题（如延迟、错误率高、资源使用率高等）。  
查看监控仪表盘：检查SkyWalking提供的监控仪表盘，查看是否有异常的指标。  
分析链路追踪数据：在SkyWalking的UI中查看链路追踪数据，找到响应慢、失败率高或者资源使用异常的链路。  
查看日志：分析与问题相关的日志信息，找到可能的错误或异常。       
调查代码和配置：根据追踪信息定位到具体的服务和代码段，检查可能的问题代码和配置。   
解决问题：修改代码或配置，解决问题后进行测试，确保问题解决。  



## 5.mysql 索引和B+树
#####  索引
索引是帮助MySQL快速获取数据的一种数据结构；  
创建索引可以有效降低磁盘I/O的次数；  

##### 索引的优缺点
1.2.1 优点
降低磁盘I/O的次数，提高数据获取效率；  
创建唯一索引，可以保证数据库表中每一行数据的唯一性 ；  
在实现数据的参考完整性方面，可以加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度；  
在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间 ，降低了CPU的消耗；  
1.2.2 缺点  
创建和维护索引需要耗费时间；  
索引需要占据磁盘空间；  
索引会导致数据表的更新效率变低；   


##### B+树
Inodb存储引擎 默认是 B+Tree索引；MyISAM 存储引擎 默认是Fulltext索引；Memory 存储引擎 默认 Hash索引；   

InnoDB 存储引擎选择使用B+树作为索引结构，是因为B+树具有以下特点和优势：   

聚簇索引支持：InnoDB 存储引擎的表数据是按照聚簇索引组织的，即数据行的物理存储顺序与聚簇索引的顺序一致。B+树的叶子节点上存储了完整的数据行，因此适合作为聚簇索引的索引结构。   

范围查询高效：B+树是一种有序的索引结构，能够高效支持范围查询操作，例如大于、小于、区间查询等。B+树的叶子节点形成了一个有序链表，可以通过链表遍历来获取范围查询结果。   

数据访问快速：B+树的高度相对较低，通常只需要几层就可以覆盖大量的数据，因此在平均情况下，B+树的数据访问时间复杂度为O(log N)，其中N是索引的数据量。这使得B+树在大型数据库中处理大量数据时表现出色。  

适应性强：B+树的节点大小相对较大，能够容纳更多的索引键和数据行。同时，B+树的叶子节点形成了有序链表，便于范围查询和顺序遍历。这种特性使得B+树适用于处理随机和顺序访问的场景。  

支持快速插入和删除：B+树的结构特点使得插入和删除操作相对简单和高效。当插入新数据时，只需对树进行少量的节点分裂和合并操作。当删除数据时，只需进行节点合并和删除操作即可。  

综上所述，B+树在适应性、范围查询、数据访问速度和快速插入删除等方面都具有优势，因此InnoDB 存储引擎选择B+树作为索引结构来满足对高性能和高并发的需求。     

另外，B+树(叶节点保存数据，其他的节点 全部存放索引)，数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。 B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。正如上面所说，在数据库中基于范围的查询是非常频繁的，因此MySQL最终选择的索引结构是B+树而不是B树。


## 6.MQ原理
##### 对于 MQ 来说，不管是 RocketMQ、Kafka 还是其他消息队列，它们的本质都是：一发一存一消费。下面我们以这个本质作为根，一起由浅入深地聊聊 MQ。   

01 从 MQ 的本质说起    
将 MQ 掰开了揉碎了来看，都是「一发一存一消费」，再直白点就是一个「转发器」。   
生产者先将消息投递一个叫做「队列」的容器中，然后再从这个容器中取出消息，最后再转发给消费者，仅此而已。   

消息队列最原始的模型，它包含了两个关键词：消息和队列。   

1、消息：就是要传输的数据，可以是最简单的文本字符串，也可以是自定义的复杂格式（只要能按预定格式解析出来即可）。   
2、队列：大家应该再熟悉不过了，是一种先进先出数据结构。它是存放消息的容器，消息从队尾入队，从队头出队，入队即发消息的过程，出队即收消息的过程。  


 ##### 透过模型看 MQ 的应用场景   
目前，MQ 的应用场景非常多，大家能倒背如流的是：系统解耦、异步通信和流量削峰。除此之外，还有延迟通知、最终一致性保证、顺序消息、流式处理等等。    

##### 消息丢失和重复消费
1.生产者发送确认。确保生产者在发送消息后等待消息队列的确认。如果网络出现问题，可以重试发送消息。16   
2.消息大小检查。确保消息大小符合消息队列的限制。如果消息过大，可以考虑拆分或压缩消息。1  
3.错误处理和重试机制。在消费者端实施异常处理和重试机制。当消费者处理消息失败时，可以重新尝试处理或将消息放入死信队列。13  
4.消息持久化。在可能的范围内，将消息持久化到磁盘，以防止因系统故障导致的消息丢失。24  
5.消费者确认机制。正确实现消费者的确认机制，确保已处理的消息不会被重复消费。45  
6.监控和告警。建立监控系统来跟踪消息队列的状态、消息数量、消费者状态等关键指标。一旦出现异常，及时发出警报。3  
7.事务性消息。使用事务性消息确保消息在发送和接收过程中的完整性和顺序性。5  
8.消费者超时设置。调整消费者的超时设置，确保消费者能够及时处理消息。  
9.消息顺序性。如果消息的顺序性很重要，应确保相关消息被发送到同一分区或队列中。4  
10.死信队列的实现。当消息处理失败达到最大重试次数后，将消息发送到死信队列中进行进一步处理。34  

##### 消息堆积问题如何解决
MQ（消息队列）的消息堆积问题是指由于消费者处理速度跟不上生产者的消息产生速度，导致消息在消息队列中积压的情况。解决消息堆积问题可以从以下几个方面入手：   

增加消费者数量：通过增加消费者的数量，可以提高消息的处理速度，从而减少消息堆积的情况。可以通过水平扩展的方式，将消息分发给多个消费者进行处理。   

提高消费者的处理能力：优化消费者的处理逻辑和算法，提高消息的消费效率。可以通过使用多线程或多进程方式处理消息，或者使用并行计算技术来加速消息处理。    

设置合理的消息队列容量：根据业务需求和系统负载情况，设置合理的消息队列容量。如果消息队列容量过小，可能会导致消息丢失；如果容量过大，可能会导致消息延迟增加。根据实际情况进行调优。    

使用消息确认机制：在消费者消费消息完成后，及时向消息队列发送确认消息，告知消息队列该消息已经成功消费，从而可以删除该消息。使用消息确认机制可以避免消息重复消费和消息丢失的问题    。
 
监控和报警：建立监控和报警系统，实时监控消息队列的积压情况。当积压达到一定阈值时，及时发出警报，以便及时处理。   

增加硬件资源：如果以上方法无法解决消息堆积问题，可以考虑增加硬件资源，如增加消息队列的服务器数量、提升服务器的性能等，以提高消息处理能力。  

##### MQ的消息顺序性
MQ（消息队列）通常使用以下几种方式来保证消息的顺序性：   
 
单一消费者：通过限制只有一个消费者来处理消息，可以保证消息的顺序性。这种方式适用于只有一个消费者的场景，但是在高并发情况下可能会成为瓶颈。  

分区排序：将消息按照某个规则进行分区，每个分区中的消息按照顺序处理。这种方式适用于可以将消息划分为多个不相互依赖的分区的场景。  

消息排序字段：在消息中添加一个排序字段，消费者在处理消息时按照该字段的顺序进行处理。这种方式适用于消息的排序字段是明确的，且消费者可以根据该字段进行排序。  

消费者缓存排序：消费者在接收到消息后，将消息缓存起来，然后按照顺序进行处理。这种方式适用于消息的顺序性对于消费者来说非常重要的场景。   

需要注意的是，以上方法可以保证消息在一定程度上的顺序性，但是在高并发和分布式环境下，由于网络延迟和负载均衡等因素，无法完全保证消息的绝对顺序性。因此，在设计应用时，需要根据实际需求和场景来选择合适的保证方式。    

##### MQ高并发情况
MQ（消息队列）可以通过多种方式来处理生产者和消费者的高并发情况，下面是一些常见的方法：  

分区和分片：将数据分散到不同的分区或分片中，以便可以并发处理。每个分区或分片可以有自己的生产者和消费者，从而提高并发性。  

负载均衡：将消息平均分配给多个消费者，以便可以同时处理多个消息。可以使用负载均衡算法，如轮询、随机或基于权重的算法来实现。  

异步处理：生产者将消息发送到MQ后，不需要等待消费者处理完毕，而是立即返回，从而提高生产者的并发性。消费者可以异步地从MQ中获取消息进行处理。  

多线程处理：消费者可以使用多线程来处理消息，以提高并发性。可以将消息分配给不同的线程来处理，每个线程可以独立地处理自己的消息。  

批量处理：消费者可以批量获取和处理消息，以减少MQ的访问次数，从而提高并发性能。可以设置每次获取的消息数量，然后一次性处理多个消息。  

消息预取：消费者可以提前从MQ中获取一定数量的消息，以便在处理完当前消息后，可以立即处理下一个消息，从而提高并发性。  
 
消息确认机制：MQ可以提供消息确认机制，确保消息发送成功后才被消费者接收。这样可以避免消息丢失或重复消费的问题   

