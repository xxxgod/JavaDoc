## 自我介绍

\1. ⽤简单的话说清楚⾃⼰主要的技术栈于擅⻓的领域；
\2. 把重点放在⾃⼰在⾏的地⽅以及⾃⼰的优势之处；
\3. 重点突出⾃⼰的能⼒⽐如⾃⼰的定位的bug的能⼒特别厉害；

## 线程池的使用

https://mp.weixin.qq.com/s/WbaqrAsTF1WkNcDR86K07w

## List的常⻅实现类

- Arraylist 与 LinkedList 都是不同步的，也就是不保证线程安全
  ArrayList 是⼀个数组队列，相当于动态数组。它由数组实现，随机访问效率⾼，随机插⼊、随机删除效
  率低。
- LinkedList 是⼀个双向链表。它也可以被当作堆栈、队列或双端队列进⾏操作。LinkedList随机访问
  效率低，但随机插⼊、随机删除效率⾼。
- Vector 是⽮量队列，和ArrayList⼀样，它也是⼀个动态数组，由数组实现。但是ArrayList是⾮线程安全
  的，⽽Vector是线程安全的。

## Spring 中的单例 bean 的线程安全问题了解吗

⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问
题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程
安全问题。

常⻅的有两种解决办法：
1.在Bean对象中尽量避免定义可变的成员变量（不太现实）。
2.在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的
⼀种⽅式）。

## 说说对线程安全的理解

多线程访问同⼀个对象，如果不需要考虑额外的同步，调⽤对象的⾏为就可以获得正确的结果就是线程
安全

## HashMap Hashtable的区别

- 线程是否安全： HashMap 是⾮线程安全的，HashTable 是线程安全的；HashTable 内部的⽅法
  基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap
  吧！）；
- 效率： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，HashTable 基本被
  淘汰，不要在代码中使⽤它；

- 对Null key 和Null value的⽀持： HashMap 中，null 可以作为键，这样的键只有⼀个，可以有⼀
  个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有⼀个 null， 直接抛出
  NullPointerException。
- 初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的
  初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后
  每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你
  给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 tableSizeFor() ⽅法保
  证，下⾯给出了源代码)。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介绍到为什
  么是2的幂次⽅。

- 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈
  值（默认为8）时，将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。

## ConcurrentHashMap 和 Hashtable 的区别

主要体现在实现线程安全的⽅式上不同。

底层数据结构： JDK1.7的 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现，JDK1.8 采⽤的数
据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的
底层数据结构类似都是采⽤ 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希
冲突⽽存在的；

实现线程安全的⽅式（重要）： 

① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组
进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数
据，就不会存在锁竞争，提⾼并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，⽽是直接
⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和CAS 来操作。（JDK1.6
以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在
JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

②Hashtable(同⼀把锁) :使⽤ synchronized 来保证线程安全，效率⾮常低下。当⼀个线程访问同步⽅法
时，其他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如 使⽤ put 添加元素，另⼀个线程不能
使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈效率越低。

## 为什么要使⽤多线程呢

1. 先从总体上来说：
   从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成
   本远远⼩于进程。另外，多核 CPU 时代意味着多个线程可以同时运⾏，这减少了线程上下⽂切换的开
   销。
2. 从当代互联⽹发展趋势来说： 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编
   程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及 性能。
3. 再深⼊到计算机底层来探讨：
   单核时代： 在单核时代多线程主要是为了提⾼ CPU 和 IO 设备的综合利⽤率。举个例⼦：当只有⼀个
   线程的时候会导致 CPU 计算时，IO 设备空闲；进⾏ IO 操作时，CPU 空闲。我们可以简单地说这两者的
   利⽤率⽬前都是 50%左右。但是当有两个线程的时候就不⼀样了，当⼀个线程执⾏ CPU 计算时，另
   外⼀个线程可以进⾏ IO 操作，这样两个的利⽤率就可以在理想情况下达到100%了。
   多核时代: 多核时代多线程主要是为了提⾼ CPU 利⽤率。举个例⼦：假如我们要计算⼀个复杂的任务，
   我们只⽤⼀个线程的话，CPU 只会⼀个 CPU 核⼼被利⽤到，⽽创建多个线程就可以让多个 CPU 核⼼被
   利⽤到，这样就提⾼了 CPU 的利⽤率

## 使⽤多线程可能带来什么问题

并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序
运⾏速度的，⽽且并发编程可能会遇到很多问题，

⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。

## 并发编程的三个重要特性

**原⼦性 :** ⼀个的操作或者多次操作，要么所有的操作全部都得到执⾏并且不会收到任何因素的⼲扰⽽中
断，要么所有的操作都执⾏，要么都不执⾏。 synchronized 可以保证代码⽚段的原⼦性。

**可⻅性 ：**当⼀个变量对共享变量进⾏了修改，那么另外的线程都是⽴即可以看到修改后的最新值。
volatile 关键字可以保证共享变量的可⻅性。

**有序性 ：**代码在执⾏的过程中的先后顺序，Java 在编译器以及运⾏期间的优化，代码的执⾏顺序未必就
是编写代码时候的顺序。 volatile 关键字可以禁⽌指令进⾏重排序优化。

## ThreadLocal简介

通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的
专属本地变量该如何解决呢？ JDK中提供的 Thread Local 类正是为了解决这样的问题。Thread Local
类主要解决的就是让每个线程绑定⾃⼰的值，可以将 ThreadLocal 类形象的⽐喻成存放数据的盒⼦，
盒⼦中可以存储每个线程的私有数据。

如果你创建了一个 ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也
是 ThreadLocal 变量名的由来。他们可以使get和set方法来获取默认值或将其值更改为当前线程所存的
副本的值，从⽽避免了线程安全问题。

## 跨域问题

为了保证安全，同源策略是一种约定，它是浏览器最核心也会是最基本的安全功能，如果缺少了同源策
略，则浏览器的正常功能可能都会受到影响。它约定请求的url地址，必须与浏览器的url地址处于同域
上，也就是域名，端口，协议都相同。如果不同，就会报错：

浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域
如何解决；

1、Jason跨域
2、nginx反向代理
3、后台做控制，允许所有源访问，访问的方式

## spring注入bean的方式

- 使用属性的setter方法注入 这是最常用的方式；
- 使用构造器注入；
- 使用Filed注入（用于注解方式）

## Bean 的生命周期

Spring IOC 容器对 Bean 的生命周期进行管理的过程:

- 通过构造器或工厂方法创建 Bean 实例
- 为 Bean 的属性设置值和对其他 Bean 的引用
- 将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法
  (applyBeanPostProcessorsBeforeInitialization)
- 调用 Bean 的初始化方法(invokeInitMethods)
- 将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization 方法
- Bean 可以使用了(applyBeanPostProcessorsAfterInitialization)
- 当容器关闭时, 调用 Bean 的销毁方法

## redis的数据类型和使用场景

redis不仅支持k/v类型的数据，同时还提供了list，set，zset，hash数据结构的存储。



string: 此类型和memcache相似，作为常规的key-value缓存应用。例如微博数、粉丝数等

hash:主要用来存储对象信息，如用户信息

list:列表是简单的字符串列表，按照插入顺序排序(内部实现为LinkedList)，可以选择将一个链表插入到
头部或尾部。Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列
表，粉丝列表等都可以用Redis的list结构来实现。

set：在微博中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还
为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功
能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集
合中。

zset: 排行榜 常用命令：zadd,zrange

## JVM调优

Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo



jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。

jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机
进程中的类装载、内存、垃圾收集、JIT编译等运行数据。

jmap，JVM Memory Map命令用于生成heap dump文件

jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了
一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看

jstack，用于生成java虚拟机当前时刻的线程快照。

jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。
常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer
Tool)、GChisto。

jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控
和管理控制台，用于对JVM中内存，线程和类等的监控

jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。

MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java
heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗

GChisto，一款专业分析gc日志的工具
https://www.cnblogs.com/it-deepinmind/p/12408911.html

## 内存溢出如何解决（JVM调优也可以说）

```
引起内存溢出的原因有很多种，常见的有以下几种：
1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
3.代码中存在死循环或循环产生过多重复的对象实体；
4.使用的第三方软件中的BUG；
5.启动参数内存值设定的过小；
```

第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)

第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。

第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内
存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线
后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查
询。
2.检查代码中是否有死循环或递归调用。
3.检查是否有大循环重复产生新对象实体。
4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内
存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中 数据较少，不容易出问题，上线
后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查
询。
5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对
对象的引用，使得这些对象不能被GC回收。

第四步，使用内存查看工具动态查看内存使用情况
java打印内存堆栈日志HeapDumpOnOutOfMemoryError，然后使用内存使用监控工具jvmstat

## SQL调优

做MySQL优化，我们要善用EXPLAIN查看SQL执行计划。
写SQL记住优化原则，效率至少提高3倍



**EXPLAIN**执行计划

type列，连接类型。一个好的SQL语句至少要达到range级别。杜绝出现all级别。

key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式。

key_len列，索引长度。

rows列，扫描行数。该值是个预估值。

extra列，详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。

**SQL语句中IN包含的值不应过多**
MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好
序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num
in(1,2,3) 对于连续的数值，能用between就不要用in了；再或者使用连接来替换。

**SELECT语句务必指明字段名称**
SELECT*增加很多不必要的消耗（CPU、IO、内存、网络带宽）；增加了使用覆盖索引的可能性；
当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。
如果排序字段没有用到索引，就尽量少排序
尽量用union all代替union
union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排
序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重
复数据。
分段查询
在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行
数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。

**不建议使用%前缀模糊查询**
例如LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用
LIKE “name%”。

**对于联合索引来说，要遵守最左前缀法则**
举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但
是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用
的查询字段放在最前面。

**必要时可以使用force index来强制查询走某个索引**
有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我
们想要的。这时就可以采用forceindex来强制优化器使用我们制定的索引。
注意范围查询语句
对于联合索引来说，如果存在范围查询，比如between、>、<等条件时，会造成后面的索引字段失
效。

**关于JOIN优化，小表驱动大表**
LEFT JOIN A表为驱动表，INNER JOIN MySQL会自动找出那个数据少的表作用驱动表，RIGHT
JOIN B表为驱动表。



**架构上**
分库分表：数据量太大，达到单库单表的瓶颈

读写分离：适合读多写少的情况

## 分布式事务

一般来说，分布式事务的实现主要有以下 5 种方案：

- XA 方案
- TCC 方案
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知方案

https://blog.csdn.net/weixin_34211761/article/details/91441749

## 分布式锁

基于数据库实现分布式锁；

基于缓存（Redis等）实现分布式锁；

基于Zookeeper实现分布式锁；

https://blog.csdn.net/wuzhiwei549/article/details/80692278

## mysql回表

回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非
主键索引的查询需要多扫描一棵索引树。

因此，可以通过索引先查询出id字段，再通过主键id字段，查询行中的字段数据，即通过再次查询提供
MySQL查询速度

https://www.cnblogs.com/zhangshengdong/p/12917637.html