##  JAVA语言特点

##### Java 语言特点

1. 简单易学；
2. 面向对象（封装，继承，多态）；
3. 平台无关性（ Java 虚拟机实现平台无关性）；
4. 可靠性；
5. 安全性；
6. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
8. 编译与解释并存；

##### 面向对象

面向对象和面向过程的区别

- 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。
- 面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。

## 数据类型

八种基本数据类型：byte、short、int、long、float、double、boolean、char

**byte**

8位、有符号的以二进制补码表示的整数 min :    -128（-2^7）max:   127(2^7-1) default: 0

对应包装类：Byte



**short**

16位、有符号的以二进制补码表示的整数 min :    -32768（-2^15）max:   32767（2^15 - 1）default: 0

对应包装类：Short



**int**

32位、有符号的以二进制补码表示的整数 min :    -2,147,483,648（-2^31）max:   2,147,483,647（2^31 - 1）default: 0  

对应包装类：Integer



**long**

64位、有符号的以二进制补码表示的整数 min :    -9,223,372,036,854,775,808（-2^63）max:  9,223,372,036,854,775,807（2^63 -1）default: 0

对应的包装类：Long



**float**

单精度、32位、符合IEEE 754标准的浮点数

float 在储存大型浮点数组的时候可节省内存空间  浮点数不能用来表示精确的值，如货币 default: 0.0f

对应的包装类：Float



**double**

双精度、64位、符合IEEE 754标准的浮点数 浮点数的默认类型为double类型 double类型同样不能表示精确的值，如货币  default: 0.0d

对应的包装类：Double



**char**

char类型是一个单一的 16 位 Unicode 字符  最小值是 \u0000（即为0） 最大值是 \uffff（即为65,535） char 数据类型可以储存任何字符

对应的包装类：Character



**boolean**

boolean数据类型表示一位的信息  只有两个取值：true 和 false 这种类型只作为一种标志来记录 true/false 情况

对应的包装类：Boolean



#### 自动装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；


## 异常

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。`Exception` 能被程序本身处理(`try-catch`)， `Error` 是无法处理的(只能尽量避免)。

`Exception` 和 `Error` 二者都是 Java 异常处理的重要子类，各自都包含大量子类。

- **Exception** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。
- **Error** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获 。例如，Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

**受检查异常**

Java 代码在编译过程中，如果受检查异常没有被 `catch`/`throw` 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。

除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、`ClassNotFoundException` 、`SQLException`...。

**不受检查异常**

Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。

`RuntimeException` 及其子类都统称为非受检查异常，例如：`NullPointExecrption`、`NumberFormatException`（字符串转换为数字）、`ArrayIndexOutOfBoundsException`（数组越界）、`ClassCastException`（类型转换错误）、`ArithmeticException`（算术错误）等。



####  Throwable 类常用方法

- **public string getMessage()**:返回异常发生时的简要描述

- **public string toString()**:返回异常发生时的详细信息

- **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage（）`返回的结果相同

- **public void printStackTrace()**:在控制台上打印 `Throwable` 对象封装的异常信息

  

#### try-catch-finally

- **try块：** 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。

- **catch块：** 用于处理 try 捕获到的异常。

- **finally 块：** 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

  

**在以下 3 种特殊情况下，finally 块不会被执行：**

1. 在 `try` 或 `finally `块中用了 `System.exit(int)`退出程序。但是，如果 `System.exit(int)` 在异常语句之后，`finally` 还是会被执行
2. 程序所在的线程死亡。
3. 关闭 CPU。



## 泛型
1.在创建对象或调用方法的时候才明确具体的类型
2.好处就是代码更加简洁，不需要强制转换，程序更加健壮，在编译期间没有警告，运行期间不会有类型转换异常

## 反射
##### 1、什么是JAVA的反射

- 在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。
- 对于任意一个对象，都能够调用它的任何方法和属性。

这种动态获取信息以及动态调用对象的方法的功能称为JAVA的反射。

##### 2、反射的作用

在JAVA中，只有给定类的名字，就可以通过反射机制来获取类的所有信息，可以动态的创建对象和编译。

##### 3、反射的原理

JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。

反射的实现主要借助以下四个类：

   Class：类的对象

   Constructor：类的构造方法

   Field：类中的属性对象

   Method：类中的方法对象

**4、反射会影响性能，有什么方式可以减低它的性能影响吗？**
答案：可以使用缓存把反射的元数据存储起来，下一次使用的时候就可以直接从内存获取了。尽可能使用高性能的反射框架（都帮你封装好了，不用自己实现）。



## 文件与IO流

#### （1）java中有几种类型的流？

字符流和字节流。字节流继承inputStream和OutputStream,字符流继承自InputSteamReader和OutputStreamWriter。

#### （2）谈谈Java IO里面的常见类，字节流，字符流、接口、实现类、方法阻塞

答：输入流就是从外部文件输入到内存，输出流主要是从内存输出到文件。
IO里面常见的类，第一印象就只知道IO流中有很多类，IO流主要分为字符流和字节流。字符流中有抽象类InputStream和OutputStream，它们的子类FileInputStream，FileOutputStream,BufferedOutputStream等。字符流BufferedReader和Writer等。都实现了Closeable, Flushable, Appendable这些接口。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。
java中的阻塞式方法是指在程序调用改方法时，必须等待输入数据可用或者检测到输入结束或者抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如read()和readLine()方法。

#### （3）字符流和字节流有什么区别？

要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。

在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？
计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。

底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。

#### （4）讲讲NIO

答：看了一些文章，传统的IO流是阻塞式的，会一直监听一个ServerSocket，在调用read等方法时，他会一直等到数据到来或者缓冲区已满时才返回。调用accept也是一直阻塞到有客户端连接才会返回。每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。并且多线程处理多个连接。每个线程拥有自己的栈空间并且占用一些 CPU 时间。每个线程遇到外部未准备好的时候，都会阻塞掉。阻塞的结果就是会带来大量的进程上下文切换。
对于NIO，它是非阻塞式，核心类：
1.Buffer为所有的原始类型提供 (Buffer)缓存支持。
2.Charset字符集编码解码解决方案
3.Channel一个新的原始 I/O抽象，用于读写Buffer类型，通道可以认为是一种连接，可以是到特定设备，程序或者是网络的连接。


## 过滤器与拦截器
#### 过滤器
filter也称之为过滤器，它是javaWeb三大组件之一（Servlet程序、Listener监听器、Filter过滤器）     
作用：既可以对请求进行拦截，也可以对响应进行处理。    
常见场景：权限检查，日记操作、拦截请求、过滤操作、对请求字符设置编码。 
##### 配置   
配置一个过滤器：
1）启动类上增加注解@ServletComponentScan    
2）新建一个类使其实现Filter接口，并实现里面的三个方法    
3）在新建类上加上@WebFilter()注解，配置需要拦截的规则        
4）在doFilter方法中控制filterChain.doFilter(servletRequest, servletResponse)调用

####  拦截器
SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。谈到拦截器，还要向大家提一个词—拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段是时，拦截器链中拦截器就会按其之前定义的顺序被调用。
##### 拦截器与过滤器的区别
过滤器是Servlet规范中的一部分，任何java web工程都可以使用。拦截器是 SpringMVC 框架自己的，只有使用了SpringMVC框架的工程才能用。过滤器在web.xml中的 url-pattern 标签中配置了 /* 之后，可以对所有要访问的资源拦截。
我们要想自定义拦截器， 要求必须实现：HandlerInterceptor 接口。

要自己配置一个拦截器，就必须用到HandlerInterceptor和WebMvcConfigurer这两个接口。



