## 概念

**Java 虚拟机（JVM）**是 Java 程序运行的基础，它就像是一个虚拟的计算机环境，能让 Java 字节码在不同操作系统和硬件上运行，实现 “一次编写，到处运行” 。

从**功能上**看，JVM 的核心能力首先是内存管理，它有自动垃圾回收机制，帮我们处理对象内存的分配和回收，避免内存泄漏等问题；其次，JVM 负责执行字节码，通过解释或编译的方式，将字节码转化为机器码供计算机执行；它还提供了平台无关性，无论我们在 Windows、Linux 还是 Mac 上运行，只要安装了 JVM，字节码就可以正确执行。

在 JVM 的**体系结构**方面，它主要包含类加载器子系统、运行时数据区、执行引三个关键部分。类加载器子系统负责加载字节码文件，采用双亲委派机制，确保类加载的安全和统一；运行时数据区是程序运行时数据存储的地方，包括堆（存对象实例）、栈（记录方法调用）、方法区（存类信息等）、程序计数器（记录指令地址）和本地方法栈；执行引擎负责执行字节码指令，与数据区交互完成操作；本地方法接口则让 Java 程序能调用本地代码，实现与底层系统的交互。

对 Java 开发来说，JVM 的作用非常重要。它屏蔽了底层差异，让我们专注于业务逻辑；安全管理器等机制保障了程序运行安全；即时编译等优化技术，还有垃圾回收对内存的高效管理，都提升了程序性能。

## **JVM内存结构**

**堆、栈、方法区、本地方法栈、程序计数器**

**其中，线程私有的：**
程序计数器
虚拟机栈
本地方法栈

**线程共享的：**
堆
方法区
直接内存 (非运行时数据区的一部分)

#### 1.**程序计数器**

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

从上面的介绍中我们知道程序计数器主要有两个作用：

字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

####  **2.Java 虚拟机栈**

与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。

StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。
Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

**扩展：那么方法/函数如何调用？**

Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java 方法有两种返回方式：

1. return 语句。
2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出。

#### 3.本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

#### 4.堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

**Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

#### 5.方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。

#### 方法区和永久代的关系

> 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。



## 类的加载概述

参考：https://blog.csdn.net/zhaocuit/article/details/93038538

当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化。

**1. 加载**：是将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。

**2. 连接**：

（1）验证是否有正确的内部结构，并和其他类协调一致。

（2）准备负责为类的静态成员分配内存，并设置默认初始化值。

（3）解析将类的二进制数据中的符号引用替换为直接。

**3. 初始化**：就是我们以前讲过的初始化步骤。



## GC垃圾回收

[参考资料：JVM垃圾回收](https://snailclimb.gitee.io/javaguide/#/wiki/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_4-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8)

**1.堆内存分配策略：**

![对象死亡](https://xxxgod.github.io/JavaDoc/image/jvm/jvm0.png)

**2.如何判断对象已经死亡？**

![对象死亡](https://xxxgod.github.io/JavaDoc/image/jvm/jvm1.png)

**3.垃圾收集器：**

Serial 收集器

ParNew 收集器

Parallel Scavenge 收集器

Serial Old 收集器

Parallel Old 收集器

CMS 收集器

G1 收集器

ZGC 收集器   



## 垃圾回收的过程

实战演示从OOM推导出JVM GC时候基于的内存结构：Young Generation（Eden、From、To）、OldGeneration、Permanent Generation

![对象死亡](https://xxxgod.github.io/JavaDoc/image/jvm/jvm3.png)

JVMHeap区域(年轻代、老年代)和方法区(永久代)结构图：

![对象死亡](https://xxxgod.github.io/JavaDoc/image/jvm/jvm4.png)

从Java GC的角度解读代码：程序20行new的Person对象会首先会进入年轻代的Eden中（如果对象太大可能直接进入年老代）。在GC之前对象是存在Eden和from中的，进行GC的时候Eden中的对象被拷贝到To这样一个survive空间（survive（幸存）空间：包括from和to，他们的空间大小是一样的，又叫s1和s2）中（有一个拷贝算法），From中的对象（算法会考虑经过GC幸存的次数）到一定次数（阈值（如果说每次GC之后这个对象依旧在Survive中存在，GC一次他的Age就会加1，默认15就会放到OldGeneration。但是实际情况比较复杂，有可能没有到阈值就从Survive区域直接到Old Generation区域。在进行GC的时候会对Survive中的对象进行判断，Survive空间中有一些对象Age是一样的，也就是经过的GC次数一样，年龄相同的这样一批对象的总和大于等于Survive空间一半的话，这组对象就会进入old Generation中，（是一种动态的调整））），会被复制到OldGeneration，如果没到次数From中的对象会被复制到To中，复制完成后To中保存的是有效的对象，Eden和From中剩下的都是无效的对象，这个时候就把Eden和From中所有的对象清空。在复制的时候Eden中的对象进入To中，To可能已经满了，这个时候Eden中的对象就会被直接复制到Old Generation中，From中的对象也会直接进入Old Generation中。就是存在这样一种情况，To比较小，第一次复制的时候空间就满了，直接进入old Generation中。复制完成后，To和From的名字会对调一下，因为Eden和From都是空的，对调后Eden和To都是空的，下次分配就会分配到Eden。一直循环这个流程。   

好处：使用对象最多和效率最高的就是在Young Generation中，通过From to就避免过于频繁的产生FullGC（Old Generation满了一般都会产生FullGC）

虚拟机在进行MinorGC（新生代的GC）的时候，会判断要进入OldGeneration区域对象的大小，是否大于Old Generation剩余空间大小，如果大于就会发生Full GC。

刚分配对象在Eden中，如果空间不足尝试进行GC，回收空间，如果进行了MinorGC空间依旧不够就放入Old Generation，如果OldGeneration空间还不够就OOM了。

比较大的对象，数组等，大于某值（可配置）就直接分配到老年代，（避免频繁内存拷贝）

年轻代和年老代属于Heap空间的

Permanent Generation（永久代）可以理解成方法区，（它属于方法区）也有可能发生GC，例如类的实例对象全部被GC了，同时它的类加载器也被GC掉了，这个时候就会触发永久代中对象的GC。

如果OldGeneration满了就会产生FullGC满原因：

1，from survive中对象的生命周期到一定阈值

2，分配的对象直接是大对象

3，由于To 空间不够，进行GC直接把对象拷贝到年老代（年老代GC时候采用不同的算法）

如果Young Generation大小分配不合理或空间比较小，这个时候导致对象很容易进入Old Generation中，而Old Generation中回收具体对象的时候速度是远远低于Young Generation回收速度。

因此实际分配要考虑年老代和新生代的比例，考虑Eden和survives的比例

Permanent Generation中发生GC的时候也对性能影响非常大，也是Full GC


## GC算法
复制算法
引用计数法
标记清除法
标记压缩法

1.复制算法：
主要用的复制算法是在新生区（伊甸园、幸存0区、幸存1区）  
每次GC都会将伊甸园区活的对象移到幸存区中；一旦伊甸园区被GC之后就会是空的。  
幸存区中哪个区为空，另外一个区就会把活得对象转移进去。  
默认当一个对象经历15次GC之后就会进入老年区。 

2.引用计数法   
会将对象做标记，如用用到了就会计数。然后计数为0就会被清除。 

3.标记清除法   
第一次扫描这些对象，用到了就经行标记。第二次扫描对没有标记的对象进行清除。

4.标记压缩法   
先进行多次的标记清除，然后对其进行压缩。

总结    
内存效率：复制算法>标记清除算法>标记压缩算法   
内存整齐度：复制算法=标记压缩算法>标记清除算法   
内存利用率：标记压缩算法=标记清除算法>复制算法

## JVM调优
#### 调优命令   
Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo   
jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。   
jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。  
jmap，JVM Memory Map命令用于生成heap dump文件  
jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看    
jstack，用于生成java虚拟机当前时刻的线程快照。   
jinfo，JVM Conﬁguration info 这个命令作用是实时查看和调整虚拟机运行参数   

#### 调优工具  
常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory AnalyzerTool)、GChisto。    
jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存， 线程和类等的监控    
jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。   
MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Javaheap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗   
GChisto，一款专业分析gc日志的工具   


#### JVM性能调优   
#### 堆内存相关参数

##### 初始堆大小和最大堆大小

- **参数**：`-Xms`用于设置 JVM 初始堆大小，`-Xmx`用于设置 JVM 最大堆大小。
- **示例**：`-Xms512m -Xmx512m` 表示将初始堆大小和最大堆大小都设置为 512MB。
- **作用**：把初始堆大小和最大堆大小设置成相同的值，能够避免堆内存动态扩展带来的性能损耗。

##### 新生代和老年代大小

- **参数**：`-Xmn`用于设置新生代的大小；`-XX:NewRatio`用于设置老年代与新生代的比例。
- **示例**：`-Xmn256m` 直接将新生代大小设为 256MB；`-XX:NewRatio=2` 表示老年代是新生代的 2 倍，即新生代占堆内存的 1/3。
- **作用**：合理分配新生代和老年代的大小，能减少垃圾回收的频率，提高性能。对于短生命周期对象较多的应用，可适当增大新生代。

#### 垃圾回收相关参数

##### 选择垃圾回收器

- 参数

  ：不同的垃圾回收器有对应的启用参数。

  - **Serial 垃圾回收器**：`-XX:+UseSerialGC`，适用于单线程环境和小内存应用。
  - **Parallel 垃圾回收器**：`-XX:+UseParallelGC` 开启并行垃圾回收器，主要关注吞吐量；`-XX:+UseParallelOldGC` 用于老年代的并行回收。
  - **CMS（Concurrent Mark Sweep）垃圾回收器**：`-XX:+UseConcMarkSweepGC`，以获取最短回收停顿时间为目标，适合对响应时间要求较高的应用。
  - **G1（Garbage First）垃圾回收器**：`-XX:+UseG1GC`，适用于大内存、多处理器的场景，能很好地控制垃圾回收的停顿时间。

- **示例**：`java -XX:+UseG1GC Main` 表示使用 G1 垃圾回收器运行 `Main` 类。

##### 垃圾回收相关其他参数

- **参数**：`-XX:MaxGCPauseMillis` 用于设置最大垃圾回收停顿时间；`-XX:GCTimeRatio` 用于设置垃圾回收时间与应用程序运行时间的比例。
- **示例**：`-XX:MaxGCPauseMillis=200` 表示最大垃圾回收停顿时间不超过 200 毫秒；`-XX:GCTimeRatio=99` 表示垃圾回收时间占总时间的比例不超过 1%。
- **作用**：通过这些参数可以对垃圾回收的性能进行更精细的控制。

#### 栈内存相关参数

##### 线程栈大小

- **参数**：`-Xss` 用于设置每个线程的栈大小。
- **示例**：`-Xss2m` 表示将每个线程的栈大小设置为 2MB。
- **作用**：对于递归调用较多的应用，可适当增大栈大小；而对于创建大量线程的应用，可适当减小栈大小以避免内存溢出。

#### 其他参数

##### 类元数据空间大小

- **参数**：`-XX:MetaspaceSize` 用于设置类元数据空间的初始大小；`-XX:MaxMetaspaceSize` 用于设置类元数据空间的最大大小。
- **示例**：`-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m` 表示初始大小为 128MB，最大为 256MB。
- **作用**：在 Java 8 及以后版本，类元数据存储在元空间，合理设置元空间大小可避免元空间溢出。

打印垃圾回收日志

- **参数**：`-XX:+PrintGCDetails` 用于打印详细的垃圾回收日志；`-XX:+PrintGCDateStamps` 用于打印垃圾回收的时间戳。
- **示例**：`-XX:+PrintGCDetails -XX:+PrintGCDateStamps`
- **作用**：通过分析垃圾回收日志，可以了解垃圾回收的频率、停顿时间等信息，为性能调优提供依据。



**参考资料：**

[JVM面试题](https://www.cnblogs.com/chengxuyuanxiaoyang/p/13692997.html)

## 场景
1.项目导致发生了OOM
一般原因：一次性申请的对象太多；内存资源耗尽未释放。
系统已经OOM了，结合j visualvm进行调试dump文件，查看最多跟业务有关对象-->找到gcroot-->查看线程栈，定位使用的方法。也可以用arthas进行故障调试

具体原因：但是我们是没法进行在服务器上去拷贝jvm dump文件的，要找运维。但是我们有堡垒机，可以经过jamp命令对堆的分析，
发现原因是导入的时候一次性生成的对象太多，因为导入的excel存在大量空行被读取。

具体解决：设置过滤空行，因为很多没一一处理。所以设置空行校验，通过注解的方式引入公共校验，在每个接口入参的时候可以限制excel文件的行数进行校验，也就是说对象不能超过一万。