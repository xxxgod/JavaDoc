## 集合的子类
![集合的子类](https://xxxgod.github.io/JavaDoc/image/base/collectionAndMap.png)

## 数组和集合的区别
数组和集合的区别:     
1:长度的区别   
数组的长度固定   
集合的长度可变   

2:内容不容   
数组存储的是同一种类型的元素   
集合可以存储不同类型的元素(但是一般我们不这样干..)   

3:元素的数据类型  
数组可以存储基本数据类型,也可以存储引用类型  
集合只能存储引用类型(你存储的是简单的int，它会自动装箱成Integer)  

## 不同集合的特点
（1）List        特点：有序（以元素的添加顺序作为集合的排列顺序，用下标索引集合中的元素。）、可重复（List因为使用下标索引元素，所以元素可重复。） 
（2）Set         特点：无序（Set的底层实现其实是Map，它是计算key的哈希值来确定元素在数组中的存放位置，所以无序）、不可重复（不重复的原理是基于hashCode和equals方法实现的。当向Set集合中添加元素时，首先会调用该元素的hashCode方法，将返回的哈希值与Set内已有元素的哈希值进行比较。如果哈希值相同，再继续调用equals方法进行比较。如果两个方法都返回true，说明该元素已存在于Set集合中，将不会再次添加，保证了元素的唯一性。）   
（3）Collection  特点：无序、可重复  
（4）Map         特点：无序（Map是通过哈希表来实现的，其中键（key）用于计算哈希值，以确定元素在哈希表中的存储位置。这意味着，当向Map中插入元素时，它们并不是按照添加顺序来存储的，因此Map被设计为无序的。），不可重复（因为map是无序的，它的查询需要通过key的值来查找，如果你定义两个同样的key,那么一个key就对应了多个值，这样就违背了java对map的定义，键和值是一一对应的。所以key不可以重复。）
                        
原文链接：https://blog.csdn.net/weixin_52071901/article/details/131180697


## Set集合常用子类
HashSet集合   
 A:底层数据结构是哈希表(是一个元素为链表的数组)  

TreeSet集合    
 A:底层数据结构是红黑树(是一个自平衡的二叉树)   
 B:保证元素的排序方式` 

LinkedHashSet集合
 A:底层数据结构由哈希表和链表组成。  

## hashMap底层结构
JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。    
JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，
那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。

## hashMap扩容   
在散列表中有装载因子这么一个属性，当装载因子*初始容量小于散列表元素时，该散列表会再散列，扩容2倍！   
装载因子的默认值是0.75，无论是初始大了还是初始小了对我们HashMap的性能都不好  
装载因子初始值大了，可以减少散列表再散列(扩容的次数)，但同时会导致散列冲突的可能性变大(散列冲突也是耗性能的一个操作，要得操作链表(红黑树)！  
装载因子初始值小了，可以减小散列冲突的可能性，但同时扩容的次数可能就会变多！   
初始容量的默认值是16，它也一样，无论初始大了还是小了，对我们的HashMap都是有影响的：  
初始容量过大，那么遍历时我们的速度就会受影响  
初始容量过小，散列表再散列(扩容的次数)可能就变得多，扩容也是一件非常耗费性能的一件事  
从源码上我们可以发现：HashMap并不是直接拿key的哈希值来用的，它会将key的哈希值的高16位进行异或操作，使得我们将元素放入哈希表的时候增加了一定的随机性。   
还要值得注意的是：并不是桶子上有8位元素的时候它就能变成红黑树，它得同时满足我们的散列表容量大于64才行的  

## ArrayList、LinkedList和Vector的区别

**ArrayList：**

查找快，因为是连续的内存空间，定位方便。但是删除、插入慢，需要发生数据迁移    
线程不安全    
底层实现是数组  
ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍  
在增删时候，需要数组的拷贝复制(navite 方法由C/C++实现)  

**LinkedList：** 

 查找慢，需要通过指针一个个寻找，但删除和插入快，只需要改变前后指针指向即可。
线程不安全  
底层实现是双向链表[双向链表方便实现往前遍历]   

**Vector：**      
线程安全
底层是数组，现在已少用，被ArrayList替代，原因有两个：  
Vector所有方法都是同步，有性能损失。  
Vector初始length是10 超过length时 以100%比率增长，相比于ArrayList更多消耗内存。  

另外：查询多用ArrayList，增删多用LinkedList。  
ArrayList增删慢不是绝对的(在数量大的情况下，已测试)：
如果增加元素一直是使用add()(增加到末尾)的话，那是ArrayList要快
一直删除末尾的元素也是ArrayList要快【不用复制移动位置】
至于如果删除的是中间的位置的话，还是ArrayList要快！
但一般来说：增删多还是用LinkedList，因为上面的情况是极端的


## hashmap和hashtable的区别  
相同点：     
实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用     

不同点：   
  1、Hashtable是早期提供的接口，HashMap是新版JDK提供的接口。   
  2、Hashtable继承Dictionary类，HashMap实现Map接口。  
  3、Hashtable线程安全，HashMap线程非安全。   
  4、Hashtable不允许null值，HashMap允许null值。  

