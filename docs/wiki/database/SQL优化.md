## MySQL优化

我们要善用EXPLAIN查看SQL执行计划。 写SQL记住优化原则，效率至少提高3倍

**1.EXPLAIN执行计划,索引**

type列，连接类型。一个好的SQL语句至少要达到range级别。杜绝出现all级别。

key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式。

key_len列，索引长度。

rows列，扫描行数。该值是个预估值。

extra列，详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。

**2.SQL语句**

**SQL语句中IN包含的值不应过多** 

MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好 序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了；再或者使用连接来替换。

**SELECT语句务必指明字段名称** 

SELECT*增加很多不必要的消耗（CPU、IO、内存、网络带宽）；增加了使用覆盖索引的可能性； 当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。 如果排序字段没有用到索引，就尽量少排序 尽量用union all代替union union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排 序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重 复数据。 分段查询 在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行 数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。

**不建议使用%前缀模糊查询** 

例如LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用 LIKE “name%”。

**对于联合索引来说，要遵守最左前缀法则** 

举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但 是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用 的查询字段放在最前面。

**必要时可以使用force index来强制查询走某个索引** 

有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我 们想要的。这时就可以采用forceindex来强制优化器使用我们制定的索引。 注意范围查询语句 对于联合索引来说，如果存在范围查询，比如between、>、<等条件时，会造成后面的索引字段失 效。

**关于JOIN优化，小表驱动大表** 

LEFT JOIN A表为驱动表，INNER JOIN MySQL会自动找出那个数据少的表作用驱动表，RIGHT JOIN B表为驱动表。

**3.缓存数据**：

建立一些redis缓存表，来差比较大的数据

**4.架构上** 

分库分表：数据量太大，达到单库单表的瓶颈；字段比较长、存储二进制数据的可以分表出来

读写分离：适合读多写少的情况，主从复制->读写分离。写到主数据库，保持主数据同步到从数据库，在从数据库读出来



## 读写分离

读写分离主要是为了将数据库的读和写操作分不到不同的数据库节点上。主服务器负责写，从服务器负责读。另外，一主一从或者一主多从都可以。

读写分离可以大幅提高读性能，小幅提高写的性能。因此，读写分离更适合单机并发读请求比较多的场景。



## 分库分表

参考资料：[JAVA 关于分库分表的学习和DEMO](https://www.jianshu.com/p/52ccdb7d5683)

分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。 常见的分库分表工具有：

sharding-jdbc（当当）TSharding（蘑菇街）Atlas（奇虎360）Cobar（阿里巴巴）MyCAT（基于Cobar）Oceanus（58同城）Vitess（谷歌）

推荐使用 sharding-jdbc 。 因为，sharding-jdbc 是一款轻量级 Java 框架，以 jar 包形式提供服务，不要我们做额外的运维工作，并且兼容性也很好。



**如何分库分表**

分库分表的核心理念就是对数据进行切分（Sharding），以及切分后如何对数据的快速定位与查询结果整合。而分库与分表都可以从：垂直（纵向）和水平（横向）两种纬度进行切分。

![img](https://pics4.baidu.com/feed/64380cd7912397dd08ef38098ca9eab0d1a287d8.jpeg?token=95ff21523342e4253e97800ca5861d8c)

下边我们就以订单相关的业务举例，看看如何做库、表的垂直和水平切分。

**垂直切分**

垂直切分有垂直分库 和垂直分表。

**1、垂直分库**

垂直分库相对来说是比较好理解的，核心理念就四个字：专库专用。

按业务类型对表进行分类，像订单、支付、优惠券、积分等相应的表放在对应的数据库中。开发者不可以跨库直连别的业务数据库，想要其他业务数据，对应业务方可以提供API接口，这就是微服务的初始形态。

垂直分库很大程度上取决于业务的划分，但有时候业务间的划分并不是那么清晰，比如：订单数据的拆分要考虑到与其他业务间的关联关系，并不是说直接把订单相关的表放在一个库里这么简单。

在一定程度上，垂直分库似乎提升了一些数据库性能，可实际上并没有解决由于单表数据量过大导致的性能问题，所以就需要配合水平切分方式来解决。

![img](https://pics6.baidu.com/feed/8c1001e93901213f61c3010b86cc6ed62e2e952c.jpeg?token=c9faa45a37060cfdf2aeb2fb514db966)

**2、垂直分表**

垂直分表是基于数据表的列（字段）为依据切分的，是一种大表拆小表的模式。

例如：一张order订单表，将订单金额、订单编号等访问频繁的字段，单独拆成一张表，把blob类型这样的大字段或访问不频繁的字段，拆分出来创建一个单独的扩展表work_extend，这样每张表只存储原表的一部分字段，再将拆分出来的表分散到不同的库中。

![img](https://pics3.baidu.com/feed/1f178a82b9014a90186f9f3a7b5c6115b21bee9c.jpeg?token=ca8d52251feb2d20f38139cca3753946)

我们知道数据库是以行为单位将数据加载到内存中，这样拆分以后核心表大多是访问频率较高的字段，而且字段长度也都较短，因而可以加载更多数据到内存中，来增加查询的命中率，减少磁盘IO，以此来提升数据库性能。

**垂直切分的优点**：

业务间数据解耦，不同业务的数据进行独立的维护、监控、扩展。在高并发场景下，一定程度上缓解了数据库的压力。**垂直切分的缺点**：

提升了开发的复杂度，由于业务的隔离性，很多表无法直接访问，必须通过接口方式聚合数据。分布式事务管理难度增加。数据库还是存在单表数据量过大的问题，并未根本上解决，需要配合水平切分。**水平切分**

前边说了垂直切分还是会存在单库、表数据量过大的问题，当我们的应用已经无法在细粒度的垂直切分时，依旧存在单库读写、存储性能瓶颈，这时就要配合水平切分一起了，水平切分能大幅提升数据库性能。

**1、水平分库**

水平分库是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，以此实现水平扩展，是一种常见的提升数据库性能的方式。

这种方案往往能解决单库存储量及性能瓶颈问题，但由于同一个表被分配在不同的数据库中，数据的访问需要额外的路由工作，因此系统的复杂度也被提升了。

例如下图，订单DB_1、订单DB_1、订单DB_3三个数据库内有完全相同的表order，我们在访问某一笔订单时可以通过对订单的订单编号取模的方式订单编号 mod 3 （数据库实例数），指定该订单应该在哪个数据库中操作。

![img](https://pics1.baidu.com/feed/3b87e950352ac65c51e2a68a29d9ea1692138a13.jpeg?token=2d4a9cae80e91285f26c83c0935a9ac2)

**2、水平分表**

水平分表是在**同一个数据库内**，把一张大数据量的表按一定规则，切分成多个结构完全相同表，而每个表只存原表的一部分数据。

例如：一张order订单表有 900万数据，经过水平拆分出来三个表，order_1、order_2、order_3，每张表存有数据 300万，以此类推。

![img](https://pics6.baidu.com/feed/b17eca8065380cd767f0d17c746ff5335882816c.jpeg?token=ef8948e85e6dafcf3da28bd5b3424fa5)

水平分表尽管拆分了表，但子表都还是在同一个数据库实例中，只是解决了单一表数据量过大的问题，并没有将拆分后的表分散到不同的机器上，还在竞争同一个物理机的CPU、内存、网络IO等。要想进一步提升性能，就需要将拆分后的表分散到不同的数据库中，达到分布式的效果。

![img](https://pics1.baidu.com/feed/b17eca8065380cd7aca99746756ff5335882819c.jpeg?token=983b7a60b69eaec50923a2d225d4f90f)

**水平切分的优点：**

解决高并发时单库数据量过大的问题，提升系统稳定性和负载能力。业务系统改造的工作量不是很大。**水平切分的缺点：**

跨分片的事务一致性难以保证。跨库的join关联查询性能较差。扩容的难度和维护量较大，（拆分成几千张子表想想都恐怖）。**一定规则是什么**

我们上边提到过很多次一定规则，这个规则其实是一种路由算法，就是决定一条数据具体应该存在哪个数据库的哪张表里。

常见的有取模算法和范围限定算法

**1、取模算法**

按字段取模（对hash结果取余数 (hash() mod N)，N为数据库实例数或子表数量）是最为常见的一种切分方式。

还拿order订单表举例，先对数据库从 0 到 N-1进行编号，对order订单表中work_no

订单编号字段进行取模，得到余数i，i=0存第一个库，i=1存第二个库，i=2存第三个库....以此类推。

这样同一笔订单的数据都会存在同一个库、表里，查询时用相同的规则，用work_no订单编号作为查询条件，就能快速的定位到数据。

**优点：**

数据分片相对比较均匀，不易出现请求都打到一个库上的情况。**缺点：**

这种算法存在一些问题，当某一台机器宕机，本应该落在该数据库的请求就无法得到正确的处理，这时宕掉的实例会被踢出集群，此时算法变成hash(userId) mod N-1，用户信息可能就不再在同一个库中了。**2、范围限定算法**

按照时间区间或ID区间来切分，比如：我们切分的是用户表，可以定义每个库的User表里只存10000条数据，第一个库只存userId从1 ~ 9999的数据，第二个库存userId为10000 ~ 20000，第三个库存userId为 20001~ 30000......以此类推，按时间范围也是同理。

**优点：**

单表数据量是可控的水平扩展简单只需增加节点即可，无需对其他分片的数据进行迁移能快速定位要查询的数据在哪个库**缺点：**

由于连续分片可能存在数据热点，比如按时间字段分片，可能某一段时间内订单骤增，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询。**分库分表的难点**

**1、分布式事务**

由于表分布在不同库中，不可避免会带来跨库事务问题。一般可使用 "三阶段提交"和 "两阶段提交" 处理，但是这种方式性能较差，代码开发量也比较大。通常做法是做到最终一致性的方案，如果不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，采用事务补偿的方式。

这里我应用阿里的分布式事务框架Seata来做分布式事务的管理，后边会结合实际案例。

**2、分页、排序、跨库联合查询**

分页、排序、联合查询是开发中使用频率非常高的功能，但在分库分表后，这些看似普通的操作却是让人非常头疼的问题。将分散在不同库中表的数据查询出来，再将所有结果进行汇总整理后提供给用户。

**3、分布式主键**

分库分表后数据库的自增主键意义就不大了，因为我们不能依靠单个数据库实例上的自增主键来实现不同数据库之间的全局唯一主键，此时一个能够生成全局唯一ID的系统是非常必要的，那么这个全局唯一ID就叫分布式ID。

**4、读写分离**

不难发现大部分主流的关系型数据库都提供了主从架构的高可用方案，而我们需要实现读写分离+分库分表，读库与写库都要做分库分表处理，后边会有具体实战案例。

**5、数据脱敏**

数据脱敏，是指对某些敏感信息通过脱敏规则进行数据转换，从而实现敏感隐私数据的可靠保护，如身份证号、手机号、卡号、账号密码等个人信息，一般这些都需要进行做脱敏处理。

**分库分表工具**

我还是那句话，尽量不要自己造轮子，因为自己造的轮子可能不那么圆，业界已经有了很多比较成熟的分库分表中间件，我们根据自身的业务需求挑选，将更多的精力放在业务实现上。

sharding-jdbc（当当）TSharding（蘑菇街）Atlas（奇虎360）Cobar（阿里巴巴）MyCAT（基于Cobar）Oceanus（58同城）Vitess（谷歌）



**为什么选 sharding-jdbc**

sharding-jdbc是一款轻量级Java框架，以jar包形式提供服务，是属于客户端产品不需要额外部署，它相当于是个增强版的JDBC驱动；相比之下像Mycat这类需要单独的部署服务的服务端产品，就稍显复杂了。况且我想把更多精力放在实现业务，不想做额外的运维工作。

sharding-jdbc的兼容性也非常强大，适用于任何基于JDBC的ORM框架，如：JPA，Hibernate，Mybatis，Spring JDBC Template或直接使用的JDBC。完美兼容任何第三方的数据库连接池，如：DBCP，C3P0，BoneCP，Druid，HikariCP等，几乎对所有关系型数据库都支持。不难发现确实是比较强大的一款工具，而且它对项目的侵入性很小，几乎不用做任何代码层的修改，也无需修改SQL语句，只需配置待分库分表的数据表即可。



## 主从复制

为什么要用mysql 的主从

1.**实现服务器负载均衡**
    即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好的客户相应时间。通常情况下，数据库管理员会有两种思路。

​    一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询

​    二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。

2.**通过复制实现数据的异地备份**
    可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。

3.**提高数据库系统的可用性**

​    数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。

​    一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道 理。

​    二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患

